package pack;/*Пакет (package) — это некий контейнер, который используется для того, чтобы изолировать имена классов. 
pack - название пакета */

import java.awt.*;/*	java. - Все стандартные классы, поставляемые с системой Java, хранятся в пакете java.
java.awt  - подключение пакета awt, содержащего базовые графические функции:GridLayout, BorderLayout и т.д.
"*"-включение всех элементов библиотеки awt */	
import java.awt.event.*;/*Подключаем объект event, который содержит свойства, описывающие некое событие.
Каждый раз, когда происходит какое-либо событие, 
объект Event передается соответствующей программе обработки.
Используемым событием в нашей программе являются ACTION события.
*/
import javax.swing.*;// библиотека для графического интерфейса
import javax.swing.border.*;//библиотека необходимая для того, чтобы установить отступы

public class Result extends JDialog {/*Класс Result, который доступен для любого файла из пакета pack наследует 
	функции элемента JDialog */
	private static final long serialVersionUID = 1L;

	public static void main(String[] args) {/*  
		Модификатор доступа public означает, что метод main(String[] args)виден и доступен любому классу. 
		static позволяет определять статические методы. Это такие методы, которые являются общими для класса, а не для
		отдельного объекта этого класса. Также они могут работать лишь со статическими полями класса.К статическим методам 
		и переменным можно обращаться через имя класса.
		void означает, что метод main(String[] args)не возвращает данных в программу, которая его вызвала, 
		а просто выводит на экран строку.
		В методе main слова String[] args означают,что этот может получать массив объектов с типом String, т.е. текстовые данные.
		Программа может состоять из нескольких классов, но только один из них содержит метод main().
		Все существующие реализации Java-интерпретаторов, получив команду интерпретировать класс, 
		начинают свою работу с вызова метода main. 
		*/
		try {/* Для задания блока программного кода, который требуется защитить от исключений, используется ключевое слово try. 
			Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
			Исключение – это проблемная ситуация, возникающая по мере выполнения кода программы. Работает она так:
			1.Выполняется код внутри блока try. 2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение 
			доходит до конца try и потом прыгает через catch. 3.Если в нём возникнет ошибка, то выполнение try на ней
			 прерывается, и управление прыгает в начало блока catch(err).
			*/
			Result Smeta = new Result(); 
			Smeta.setDefaultCloseOperation(DISPOSE_ON_CLOSE); //при закрытии формы происходит выход из приложения
			Smeta.setVisible(true); //устанавливаем что окно видимое
			Srtah_kal.calc(); //рассчитваем необходимые данные. Функция расположена в файле Strah_kal
		} catch (Exception e) {
			/* Для задания блока программного кода, который требуется защитить от исключений, используется ключевое слово try. 
			Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
			Исключение – это проблемная ситуация, возникающая по мере выполнения кода программы. Работает она так:
			1.Выполняется код внутри блока try. 2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение 
			доходит до конца try и потом прыгает через catch. 3.Если в нём возникнет ошибка, то выполнение try на ней
			 прерывается, и управление прыгает в начало блока catch(err).
			*/
			e.printStackTrace();
		}
	}

	public static JLabel Sist_label, Str_vipl_label;
	//текстовые поля,доступные из любого файла пакета pack
	/*static позволяет определять статические методы. Это такие методы, которые являются общими для класса, а не для
отдельного объекта этого класса. Также они могут работать лишь со статическими полями класса.К статическим методам 
и переменным можно обращаться через имя класса.*/

	public Result() {//метод, описывающий какие поля и кнопки располагаются на JDialog
			setTitle("Страховой калькулятор имущества"); //устанавливает название окна 
		setSize(530, 440); // указывает ширину (530) и высоту (440).
		setLocationRelativeTo(null);//установить посередине экрана
		setResizable(false); //запрет на расширение окна 
		
		getContentPane().setLayout(new BorderLayout());// для данной панели устанавливается менеджер компоновки BorderLayout
		 /*	Оператор new создает экземпляр указанного класса
	  	Метод setLayout - Вызов менеджера компоновки, который задает определенный порядок панелей в контейнере.
 		Менеджер размещения BorderLayout - тип разбивки контейнера, при котором всё пространство контейнера разбивается 
 		на пять частей. В каждой из этих частей располагается один компонент. 
 		При добавлении компонента на контейнер с BorderLayout разработчик обязательно указывает, 
 		куда именно он хочет поместить компонент.*/
		
		JPanel panel_1 = new JPanel();//Панель на которой располагается текстовое поле
		JPanel panel_2 = new JPanel(); //Панель на которой располагаются текстовые поля и поля для ввода текста
		JPanel panel_3 = new JPanel();//Панель на которой располагается кнопки

		add(panel_1, BorderLayout.NORTH);//Добавление панели Panel_Text наверх
		add(panel_2, BorderLayout.CENTER);//Добавление панели Panel_Text по центру
		add(panel_3, BorderLayout.SOUTH);//Добавление панели Panel_Button снизу

		panel_1.setBorder(new EmptyBorder(5,10,5,10));//установка внутренних отступов(5 справа и слева,10сверху и снизу)
		panel_2.setBorder(new EmptyBorder(5,10,5,10));//установка внутренних отступов

		/* установка менеджера компоновки GridLayout. данный менеджер компоновки располагает компоненты в таблицу */
		panel_1.setLayout(new GridLayout(1,1,0,15));//на панели 1 строка,1столбец ("смета затрат...")
		panel_2.setLayout(new FlowLayout(FlowLayout.LEFT, 7, 15));/* на панеле будет 15 строк, 2 столбца, расстояние между
		 столбцами 0, расстояние между строками 5 */
		panel_3.setLayout(new GridLayout(2,1));//на панели 1 строка,1столбец, будет расположена кнопка
		
		JLabel label_1 = new JLabel("Расчет величины страховых выплат.", JLabel.CENTER);
		JLabel label_2 = new JLabel("Выбрана система", JLabel.LEFT);
		JLabel label_3 = new JLabel("Величина страховых выплат составляет", JLabel.LEFT);
		JLabel label_4 = new JLabel("рублей.", JLabel.LEFT);

		/*Обозначаем что переменные Label_1,Label_2..являются объектом JLabel и указываем какой текст будет выводиться.
		JLabel.LEFT - выравнивание по левому краю,
		JLabel.CENTER - выравнивание по центру, RIGHT - по правому краю
		*/
		
		//создаем текстовые поля для того чтобы в них записывать рассчитанные результаты
		Sist_label = new JLabel("");
		Str_vipl_label = new JLabel("");
		//создаем текстовые поля для того чтобы в них записывать рассчитанные результаты

		//Добавление компонентов JLabel, JTextField, JComboBox, JCheckBox на панели panel_1 и panel_2
		panel_1.add(label_1);
		
		panel_2.add(label_2);
		panel_2.add(Sist_label);
		panel_2.add(label_3);
		panel_2.add(Str_vipl_label);
		panel_2.add(label_4);
		//Добавление компонентов JLabel, JTextField, JComboBox, JCheckBox на панели Smeta_panel и Smeta_panel_1
	
		JButton Button_del = new JButton("Очистить результаты"); /*В скобках надпись на кнопке*/
		panel_3.add(Button_del);/*  Добавление кнопки в панель */
			
		JButton Button_exit = new JButton("Закрыть");
		panel_3.add(Button_exit);
		
		Button_exit.addActionListener(new ActionListener() //добавляем слушателя события для кнопки 
				/*      "."  - указывает к какой переменной (кнопке) следует применить слушателя.
			 	addActionListener - добавление слушателя ActionListener к кнопке
			  	new - Оператор new создает экземпляр указанного класса 
			  	(Для того чтобы кнопки стали функциональными, каждой из них необходимо присвоить обработчик событий, 
			  	который будет отвечать за реагирование на события. 
			  	В нашем случае требуется идентифицировать событие нажатия кнопки – путем щелчка мышью. 
			  	Поэтому будет использоваться интерфейс "ActionListener", 
			  	предназначенный для обработки событий "ActionEvent".
			  	тело интерфейса указывается ниже после фигурной скобки "{"
	    	    */              
		   {                                                         
		    public void actionPerformed(ActionEvent e)      
		    /* 	ActionListener" имеет метод "actionPerformed" объекта "ActionEvent", 
	      	который реализуется путем простого вызова обработчика событий ActionPerformed.
	      	Ключевое слово public означает, что метод actionPerformed() доступен для любого другого класса Java
	      	Ключевое слово void означает, что метод main() не возвращает данных в программу, которая его вызвала. 
	      	*/  
		    {    // описываем что будет происходить при нажатии на кнопку Закрыть - программа завершит свою работу
	            System.exit(0);		    	
		    }                                                        
		   }); 
		

		
		Button_del.addActionListener(new ActionListener()     
				//добавляем слушателя события для кнопки 
				/*      "."  - указывает к какой переменной (кнопке) следует применить слушателя.
			 	addActionListener - добавление слушателя ActionListener к кнопке
			  	new - Оператор new создает экземпляр указанного класса 
			  	(Для того чтобы кнопки стали функциональными, каждой из них необходимо присвоить обработчик событий, 
			  	который будет отвечать за реагирование на события. 
			  	В нашем случае требуется идентифицировать событие нажатия кнопки – путем щелчка мышью. 
			  	Поэтому будет использоваться интерфейс "ActionListener", 
			  	предназначенный для обработки событий "ActionEvent".
			  	тело интерфейса указывается ниже после фигурной скобки "{"
	    	    */   
		   {		
		    public void actionPerformed(ActionEvent e)  
		    /* 	ActionListener" имеет метод "actionPerformed" объекта "ActionEvent", 
	      	который реализуется путем простого вызова обработчика событий ActionPerformed.
	      	Ключевое слово public означает, что метод actionPerformed() доступен для любого другого класса Java
	      	Ключевое слово void означает, что метод main() не возвращает данных в программу, которая его вызвала. 
	      	*/  
		    {
		    	setVisible(false);//данное окно станет невидимым
		    	Index.Frame.setVisible(true); /*устанавливаем что окно в котором пользователь вводит данные видимое */
		    	
		    	//	Обнуляем все поля, переменные, флажки ставим в состояние выключен
		    	Index.Vel_u_text.setText("");
		    	Index.Str_sum_text.setText("");    			
		    	Index.Stoim_oc_text.setText("");
		    	Index.Pokaz_stoim_text.setText("");
		    	Index.Stoim_im_text.setText("");

		    	Index.sistema_1.setSelected(false);
		    	Index.sistema_2.setSelected(false);
		    	Index.sistema_3.setSelected(false);
		    	Index.sistema_4.setSelected(false);
		    	Index.sistema_5.setSelected(false);

		    	Index.sistema_1_int=0;
		    	Index.sistema_2_int=0;
		    	Index.sistema_3_int=0;
		    	Index.sistema_4_int=0;
		    	Index.sistema_5_int=0;

		    	Index.ver=0;

		    }                                                        
		   }); 	
	}}
		
